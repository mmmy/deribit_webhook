import { 
  ConfigLoader, 
  DeribitAuth, 
  DeribitClient, 
  DeltaManager, 
  MockDeribitClient 
} from '../services';
import { DeribitPrivateAPI, createAuthInfo, getConfigByEnvironment } from '../api';
import { executePositionAdjustment } from '../services/position-adjustment';

export interface PollingResult {
  accountName: string;
  success: boolean;
  mockMode?: boolean;
  data?: any[];
  error?: string;
  timestamp: string;
}

/**
 * Position polling service - handles automated position monitoring and adjustment
 */
export class PositionPollingService {
  private configLoader: ConfigLoader;
  private deribitAuth: DeribitAuth;
  private deribitClient: DeribitClient;
  private mockClient: MockDeribitClient;
  private deltaManager: DeltaManager;
  private useMockMode: boolean;

  constructor(
    configLoader?: ConfigLoader,
    deribitAuth?: DeribitAuth,
    deribitClient?: DeribitClient,
    mockClient?: MockDeribitClient,
    deltaManager?: DeltaManager
  ) {
    // ÊîØÊåÅ‰æùËµñÊ≥®ÂÖ•Ôºå‰ΩÜ‰øùÊåÅÂêëÂêéÂÖºÂÆπ
    this.configLoader = configLoader || ConfigLoader.getInstance();
    this.deribitAuth = deribitAuth || new DeribitAuth();
    this.deribitClient = deribitClient || new DeribitClient();
    this.mockClient = mockClient || new MockDeribitClient();
    this.deltaManager = deltaManager || DeltaManager.getInstance();
    this.useMockMode = process.env.USE_MOCK_MODE === 'true';
  }

  /**
   * Poll positions for all enabled accounts
   */
  async pollAllAccountsPositions(): Promise<PollingResult[]> {
    const requestId = `poll_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;

    try {
      console.log(`üîÑ [${requestId}] Starting positions polling for all enabled accounts`);

      const accounts = this.configLoader.getEnabledAccounts();
      if (accounts.length === 0) {
        console.log(`‚ö†Ô∏è [${requestId}] No enabled accounts found for polling`);
        return [];
      }

      const results: PollingResult[] = [];

      for (const account of accounts) {
        try {
          console.log(`üìä [${requestId}] Polling account: ${account.name}`);

          if (this.useMockMode) {
            // Mock mode: generate simulated data
            const mockPositions = this.generateMockPositions();
            
            results.push({
              accountName: account.name,
              success: true,
              mockMode: true,
              data: mockPositions,
              timestamp: new Date().toISOString()
            });

            console.log(`‚úÖ [${requestId}] Mock data generated for ${account.name}: ${mockPositions.length} positions`);
          } else {
            // Real mode: call Deribit API
            const positionsData = await this.fetchRealPositions(account.name, requestId);
            
            if (positionsData.success && positionsData.data) {
              // Analyze positions for delta adjustments
              await this.analyzePositionsForAdjustment(positionsData.data, account.name, requestId);
            }

            results.push(positionsData);
          }

        } catch (accountError) {
          console.error(`‚ùå [${requestId}] Failed to poll account ${account.name}:`, accountError);
          results.push({
            accountName: account.name,
            success: false,
            error: accountError instanceof Error ? accountError.message : 'Unknown error',
            timestamp: new Date().toISOString()
          });
        }
      }

      // Summary results
      const successCount = results.filter(r => r.success).length;
      const totalPositions = results
        .filter(r => r.success)
        .reduce((sum, r) => sum + (r.data?.length || 0), 0);

      console.log(`üìä [${requestId}] Polling completed: ${successCount}/${accounts.length} accounts successful, ${totalPositions} total positions`);

      return results;

    } catch (error) {
      console.error(`üí• [${requestId}] Polling error:`, error);
      throw error;
    }
  }

  /**
   * Generate mock position data for testing
   */
  private generateMockPositions(): any[] {
    const currencies = ['BTC', 'ETH', 'SOL'];
    return currencies.map(currency => ({
      instrument_name: `${currency}-8AUG25-${currency === 'BTC' ? '113000' : currency === 'ETH' ? '3500' : '200'}-C`,
      size: Math.random() * 20 - 10, // -10 to 10
      direction: Math.random() > 0.5 ? 'buy' : 'sell',
      average_price: Math.random() * 0.05,
      mark_price: Math.random() * 0.05,
      unrealized_pnl: (Math.random() - 0.5) * 2,
      delta: (Math.random() - 0.5) * 2
    })).filter(pos => pos.size !== 0); // Only keep non-zero positions
  }

  /**
   * Fetch real position data from Deribit API
   */
  private async fetchRealPositions(accountName: string, requestId: string): Promise<PollingResult> {
    try {
      await this.deribitAuth.authenticate(accountName);
      const tokenInfo = this.deribitAuth.getTokenInfo(accountName);

      if (!tokenInfo) {
        throw new Error(`Authentication failed for ${accountName}`);
      }

      const isTestEnv = process.env.USE_TEST_ENVIRONMENT === 'true';
      const apiConfig = getConfigByEnvironment(isTestEnv);
      const authInfo = createAuthInfo(tokenInfo.accessToken);
      const privateAPI = new DeribitPrivateAPI(apiConfig, authInfo);

      // Get all option positions (not specifying currency returns all currencies' options)
      const allPositions = await privateAPI.getPositions({
        kind: 'option'
      });

      // Only keep positions with size != 0
      const activePositions = allPositions.filter(pos => pos.size !== 0);

      console.log(`‚úÖ [${requestId}] Real data fetched for ${accountName}: ${activePositions.length} active positions`);

      return {
        accountName,
        success: true,
        mockMode: false,
        data: activePositions,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error(`‚ùå [${requestId}] Failed to fetch positions for ${accountName}:`, error);
      return {
        accountName,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * Analyze positions for delta adjustments
   */
  private async analyzePositionsForAdjustment(positions: any[], accountName: string, requestId: string): Promise<void> {
    for (const pos of positions) {
      try {
        // Calculate position delta per unit = pos.delta / pos.size
        const positionDelta = pos.delta && pos.size !== 0 ? pos.delta / pos.size : 0;

        // Query Delta database records for this position
        const deltaRecords = this.deltaManager.getRecords({
          account_id: accountName,
          instrument_name: pos.instrument_name
        });

        if (deltaRecords.length > 0) {
          // Find the latest record
          const latestRecord = deltaRecords.sort((a, b) => {
            const timeA = a.created_at ? new Date(a.created_at).getTime() : 0;
            const timeB = b.created_at ? new Date(b.created_at).getTime() : 0;
            return timeB - timeA;
          })[0];

          if (latestRecord.min_expire_days != null && latestRecord.move_position_delta !== undefined) {
            const targetDeltaAbs = Math.abs(latestRecord.target_delta || 0);
            const positionDeltaAbs = Math.abs(positionDelta);

            // If |move_position_delta| < |position delta|, trigger adjustment
            if (targetDeltaAbs < positionDeltaAbs) {
              console.log(`üìä [${requestId}] Position Delta Analysis - ${accountName}:`);
              console.log(`   üéØ Instrument: ${pos.instrument_name}`);
              console.log(`   üìà Position Size: ${pos.size}`);
              console.log(`   üî¢ Position Delta: ${pos.delta?.toFixed(4) || 'N/A'}`);
              console.log(`   üìê Delta per Unit: ${positionDelta.toFixed(4)}`);
              console.log(`   üéØ Target Delta: ${latestRecord.target_delta}`);
              console.log(`   üìä Move Position Delta: ${latestRecord.move_position_delta || 0}`);
              console.log(`   ‚öñÔ∏è Condition: |${latestRecord.move_position_delta || 0}| < |${positionDelta.toFixed(4)}| = ${targetDeltaAbs < positionDeltaAbs ? 'TRUE' : 'FALSE'}`);

              // Send notification to WeChat
              await this.sendAdjustmentNotification(accountName, pos, latestRecord, requestId);

              // Trigger position adjustment
              const tokenInfo = this.deribitAuth.getTokenInfo(accountName);
              if (tokenInfo) {
                const adjustmentResult = await executePositionAdjustment(
                  {
                    requestId,
                    accountName,
                    currentPosition: pos,
                    deltaRecord: latestRecord,
                    accessToken: tokenInfo.accessToken
                  },
                  {
                    deribitClient: this.deribitClient,
                    deltaManager: this.deltaManager,
                    deribitAuth: this.deribitAuth,
                    mockClient: this.mockClient,
                    configLoader: this.configLoader
                  }
                );

                // Send result notifications
                await this.sendAdjustmentResultNotification(accountName, adjustmentResult, requestId);
              }
            }
          }
        }

      } catch (posError) {
        console.warn(`‚ö†Ô∏è [${requestId}] Failed to analyze position ${pos.instrument_name}:`, posError);
      }
    }
  }

  /**
   * Send adjustment start notification to WeChat
   */
  private async sendAdjustmentNotification(accountName: string, position: any, record: any, requestId: string): Promise<void> {
    try {
      const bot = this.configLoader.getAccountWeChatBot(accountName);
      if (bot) {
        const positionDelta = position.delta && position.size !== 0 ? position.delta / position.size : 0;
        
        const notificationContent = `üîÑ **Delta ‰ªì‰ΩçË∞ÉÊï¥ÂºÄÂßã**
üë§ **Ë¥¶Êà∑**: ${accountName}
üéØ **ÂêàÁ∫¶**: ${position.instrument_name}
üìà **‰ªì‰ΩçÂ§ßÂ∞è**: ${position.size}
üî¢ **‰ªì‰ΩçDelta**: ${position.delta?.toFixed(4) || 'N/A'}
üìê **Âçï‰ΩçDelta**: ${positionDelta.toFixed(4)}
üéØ **ÁõÆÊ†áDelta**: ${Math.abs(record.target_delta || 0)}
üìä **ÁßªÂä®‰ªì‰ΩçDelta**: ${record.move_position_delta || 0}
üìÖ **ËÆ∞ÂΩïÂàõÂª∫Êó∂Èó¥**: ${record.created_at ? new Date(record.created_at).toLocaleString('zh-CN') : 'Êú™Áü•'}
üÜî **ËÆ∞ÂΩïID**: ${record.id}
üîÑ **ËØ∑Ê±ÇID**: ${requestId}
‚è∞ **ÂºÄÂßãÊó∂Èó¥**: ${new Date().toLocaleString('zh-CN')}`;

        await bot.sendMarkdown(notificationContent);
        console.log(`üì± [${requestId}] WeChat notification sent for account: ${accountName}`);
      }
    } catch (error) {
      console.error(`‚ùå [${requestId}] Failed to send WeChat notification for account ${accountName}:`, error);
    }
  }

  /**
   * Send adjustment result notification to WeChat
   */
  private async sendAdjustmentResultNotification(accountName: string, result: any, requestId: string): Promise<void> {
    try {
      const bot = this.configLoader.getAccountWeChatBot(accountName);
      if (!bot) return;

      if (result.success) {
        // Success notification
        const successContent = `‚úÖ **Delta ‰ªì‰ΩçË∞ÉÊï¥ÊàêÂäü**

üë§ **Ë¥¶Êà∑**: ${accountName}
üìä **Ë∞ÉÊï¥ËØ¶ÊÉÖ**: ${result.oldInstrument} ‚Üí ${result.newInstrument}
üìà **‰ªì‰ΩçÂèòÂåñ**: ${result.adjustmentSummary?.oldSize} ‚Üí ${result.adjustmentSummary?.newDirection} ${result.adjustmentSummary?.newQuantity}
üéØ **ÁõÆÊ†áDelta**: ${result.adjustmentSummary?.targetDelta}
üîÑ **ËØ∑Ê±ÇID**: ${requestId}
‚è∞ **ÂÆåÊàêÊó∂Èó¥**: ${new Date().toLocaleString('zh-CN')}

üéâ **Ë∞ÉÊï¥Â∑≤ÊàêÂäüÂÆåÊàêÔºÅ**`;

        await bot.sendMarkdown(successContent);
        console.log(`üì± [${requestId}] Success notification sent for account: ${accountName}`);
      } else {
        // Error notification
        const errorContent = `‚ùå **Delta ‰ªì‰ΩçË∞ÉÊï¥Â§±Ë¥•**

üë§ **Ë¥¶Êà∑**: ${accountName}
üí¨ **Â§±Ë¥•ÂéüÂõ†**: ${result.reason}
${result.error ? `üìã **ÈîôËØØËØ¶ÊÉÖ**: \`\`\`\n${result.error}\n\`\`\`` : ''}
üîÑ **ËØ∑Ê±ÇID**: ${requestId}
‚è∞ **Â§±Ë¥•Êó∂Èó¥**: ${new Date().toLocaleString('zh-CN')}

‚ö†Ô∏è **ËØ∑Ê£ÄÊü•Á≥ªÁªüÁä∂ÊÄÅÂπ∂ÊâãÂä®Â§ÑÁêÜ**`;

        await bot.sendMarkdown(errorContent);
        console.log(`üì± [${requestId}] Error notification sent for account: ${accountName}`);
      }
    } catch (error) {
      console.error(`‚ùå [${requestId}] Failed to send result notification for account ${accountName}:`, error);
    }
  }
}